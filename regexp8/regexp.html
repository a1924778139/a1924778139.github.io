<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:regexp</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">正则表达式</h1>
<h2 id="-">什么是正则表达式?</h2>
<blockquote>
<p>正则表达式就是一个<em>用于查找的</em>含有<strong>匹配字符串</strong>或<strong>匹配元字符</strong>的字符串</p>
</blockquote>
<h2 id="-">正则表达式对象</h2>
<blockquote>
<p>js正则表达式对象就是由正则表达式创建的对象，该对象可以进行匹配，提取和替换。</p>
</blockquote>
<h3 id="-">创建正则表达式对象</h3>
<h4 id="-">构造函数</h4>
<pre><code>var regex = new RegExp(正则表达式字符串);

eg:
var regex = new RegExp(&quot;abc&quot;);//匹配包含abc的字符串
</code></pre><h4 id="-">正则字面量</h4>
<pre><code>var regex = /正则表达式/;

eg:
var rehex = /abc/; // 注意双斜线中的字符串不需要再用引号    
</code></pre><h3 id="-">正则表达式对象的基本使用</h3>
<ul>
<li><p>判断字符串‘abcdefghigkhshssgehshsgdjagsjsgahajdkadna’中是否包含某个特定的字符串</p>
</li>
<li><p>使用正则方式</p>
<pre><code>  // 匹配是否含有字符串js
  var str = &#39;abcdefghigkhshssgehshsgdjagsjsgahajdkadna&#39;; 
  // 1.创建正则对象
  // var r1 = new RegExp(&#39;js&#39;); // 构造函数形式
  var r2 = /js/; // 字面量形式

  // 2.开始检查匹配
  var res = r2.test(str);
  console.log(res);

  // 如果包含则返回true 不包含返回false
</code></pre></li>
</ul>
<h2 id="-">元字符</h2>
<h3 id="-">基本元字符</h3>
<ul>
<li><p><code>.</code>:表示任意一个非换行的字符</p>
<pre><code>  foo. 可以匹配到以foo开头的任意字符串
</code></pre></li>
<li><p><code>()</code>:表示分组和提高优先级</p>
</li>
<li><p><code>[]</code>:表示一个字符</p>
<ul>
<li>用法:[abc] 表示出现在[]中的任意一个字符 匹配a,或b,或c</li>
<li><p>可以认为是<code>.</code>的带限制升级版</p>
<pre><code>  [abc] 可以匹配到字符a或字符b或字符c
</code></pre></li>
</ul>
</li>
<li><p><code>|</code>:或的意思</p>
<ul>
<li>用法:正则表达式1|正则表达式2</li>
<li><p>可以认为是<code>[]</code>匹配多个字符串的扩展版</p>
<pre><code>  abc|123 可以匹配到字符串abc或123
</code></pre></li>
</ul>
</li>
<li><p><code>\</code>转义字符</p>
<pre><code>   表示 .: \.
   表示 [] : \[\]
   表示 (): \(\)
   表示 \ : \\
</code></pre></li>
</ul>
<h3 id="-">限定元字符</h3>
<ul>
<li><p><code>*</code>: 紧跟前面的一个字符或一组字符出现0次到多次</p>
<pre><code>  - 匹配一个字符正则:123*  前面一个字符3在后面出现的次数

  12       0次
  123       1次
  1233      2次
  12333     3次

  - 匹配一组字符正则:1(23)*  前面一组字符23在后面出现的次数
  1           0次
  123          1次
  12323        2次
</code></pre></li>
</ul>
<ul>
<li><p><code>+</code>: 紧跟在前面的字符出现一次到多次,<code>+</code>号前面的这个也匹配</p>
<pre><code>  正则123+
  123        1次
  1233    2次
</code></pre></li>
<li><p><code>？</code>: 紧跟在前面的字符出现0次或1次</p>
<pre><code>  q:在一段字符串中检查是否含有http协议字符串或https协议字符串
  a1: http://.+|https://.+   使用|匹配两者
  a2: https?://.+  s出现0次或1次正好是http或https
</code></pre></li>
<li><p><code>{数字}</code>: 紧跟在前面的字符出现指定的次数</p>
<pre><code>  正则a{3} 只能匹配到字符串中有aaa的

  aabbcc         匹配不到
  aaa            能匹配到
  aaaaaa         不能匹配
</code></pre></li>
</ul>
<ul>
<li><p><code>{数字,}</code>: 紧跟在前面的字符至少出现指定的次数</p>
<pre><code>  正则a{3,} 可以匹配到字符串中至少出现了3个aaa的

  aaa         能匹配到
  aaaaaa        能匹配到
</code></pre></li>
<li><p><code>{数字,数字}</code>: 紧跟在前面的字符出现的次数范围</p>
<pre><code>  正则a{1,3} 可以匹配到出现一次a 2次a 3次a的字符串

  abc            能匹配到
  aabc        能匹配到
  aaabc        能匹配到
</code></pre></li>
</ul>
<h3 id="-">首尾元字符</h3>
<ul>
<li><p><code>^</code>: 表示必须以指定的字符开始</p>
<pre><code>  正则^a  匹配以a开头的字符串

  abc         能匹配到
  cba        不能匹配
</code></pre></li>
<li><p><code>$</code>: 表示必须以指定的字符结尾</p>
<pre><code>  正则a$  匹配以a结尾的字符

  abc        不能匹配
  cba        能匹配到
</code></pre></li>
<li><p>案例<code>^a+$</code>: 匹配全是a的字符串</p>
<pre><code>  var reg = /^a+$/;

  console.log(reg.test(&#39;a&#39;)); // true
  console.log(reg.test(&#39;abc&#39;)); // false
  console.log(reg.test(&#39;aaaaaa&#39;)); // true
  console.log(reg.test(&#39;baaa&#39;)); // false
</code></pre></li>
</ul>
<h3 id="-">简写元字符</h3>
<ul>
<li><code>\s</code>: 空白字符(包括空格 tab 回车换行等)</li>
<li><p><code>\S</code>: 非空白字符</p>
<pre><code>  [\s\S]表示任意字符
</code></pre></li>
<li><p><code>\w</code>: 表示字符,包含字母、数字、下划线</p>
</li>
<li><p><code>\W</code>: 非字符</p>
</li>
<li><p><code>\d</code>: 数字</p>
</li>
<li><code>\D</code>: 非数字</li>
</ul>
<h3 id="-">否定元字符(负向类)</h3>
<blockquote>
<p>不出现某个需要匹配的字符,使用<code>[^字符]</code></p>
</blockquote>
<pre><code>[^abc] 不是a不是b也不是c的字符
也就是只要不是abc三个字符中任意一个都可以匹配到
</code></pre><h2 id="-">正则案例</h2>
<h3 id="-">匹配身份证</h3>
<pre><code>身份证是 18 位数字
省 市 区 出生年月 随机编码X
1) 首先是要做匹配, 就一定要使用 ^ $
2) 是 18 位数字( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ). 可以使用 [0123456789]
    还可以使用 0|1|2|3|4|5|6|7|8|9
3) 要求是 18 位. 限定 18 位, 即 {18}

组合: ^[0123456789]{18}$

如果最后一位是x
前面 17 位数字: ^[0123456789]{17}$

组合: ^[0123456789]{17}[0123456789x]$
</code></pre><h3 id="-">匹配邮箱</h3>
<pre><code>名字 @ 主机名

1) 是要验证邮箱, 那么就需要使用 ^ $
2) 名字:
    数字与字母
    [0123456789]
    [abcdefghi...]
    [ABCDEFG...]

    [] 里面的字符如果是编码序号连续的可以使用连字符连接
    数字: [0-9]  
          [9-0] 错误的, 编码逆序
    字母: [a-z]
          [A-Z]
    整合: [0-9a-zA-Z]

    名字的变式方法: [0-9a-zA-Z]+
3) 主机名
    主机名也是一串字符串或数字
    但是它多了一个 .com .cn

3.1) 只有名字     [0-9a-zA-Z]+

3.2) 只含有一个 .什么
    开始 \.
    中间 [0-9a-zA-Z]+
    只含有一个名字: \.[0-9a-zA-Z]+

3.3) 含有多个名字
    .com.con.cc.c1.c2.c3
    即 .什么 出现一次到多次

    (\.[0-9a-zA-Z]+)+

最后主机名可以写成
    [0-9a-zA-Z]+(\.[0-9a-zA-Z]+)+

最后整合一下
^[0-9a-zA-Z]+@[0-9a-zA-Z]+(\.[0-9a-zA-Z]+)+$
</code></pre><h3 id="-">匹配数字</h3>
<h4 id="-">任意整数</h4>
<pre><code>1) 由于是匹配, 包含 ^ $
2) 首先第一个字符不允许是 0, 所以第一个可以写成 [1-9]
3) 后面的数字就是 [0-9]
4) 要求后面的数字出现 0 次到多次, 以匹配任意的 非 0 数字: [1-9][0-9]*
5) 由于还需要考虑 0, 因此写成 [1-9][0-9]*|0
6) 考虑 | 优先级最低: ^([1-9][0-9]*|0)$

^(-?[1-9][0-9]*|0)$
</code></pre><h4 id="-">任意范围的整数</h4>
<pre><code>如果要匹配指定范围的数字, 那么需要将字符串结构进行分类
1) 0 要匹配的, 所以在正则表达式中有 0 这一项
2) 任意的 2 位数, 即 [1-9][0-9]
3) 任意的 1 位数, 即 [0-9], 可以将 第 1) 结论合并
4) 考虑 3 位数的时候, 只允许出现 1xx 的任意数, 而 2xx 的有限制
    因此在分组, 考虑 1xx 的任意数, 可以写成: 1[0-9][0-9]
5) 考虑 2xx 的数字, 在 200 到 250 之间允许任意取. 所以
    写成: 2[0-4][0-9]
6) 考虑 250 到 255, 写成 25[0-5]

^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$
</code></pre><h4 id="-">任意小数</h4>
<pre><code>要求, 小数不允许以 0 结尾
3.1415
[0-9]*[1-9]

^((-?[1-9][0-9]*|0)(\.[0-9]*[1-9])?)$

(aaa)?    这个内容出现或不出现
(aaa|)    也是表达aaa可出现可不出现
^((-?[1-9][0-9]*|0)(\.[0-9]*[1-9]|))$
</code></pre><h2 id="-exec-">提取(exec)</h2>
<h3 id="exec-">exec基本使用</h3>
<ul>
<li>作用:将匹配到的内容提取出来</li>
<li><p>语法:<code>正则对象.exec(&#39;字符串&#39;)</code> 返回一个装提取到的内容对象的数组</p>
<pre><code>  eg: 从‘abc123ddds567sss789lkj’中提取数字

  var str = ‘abc123ddds567sss789lkj’;
  var regexp = /\d+/;
  var result = regexp.exec(str); 

  /*只能提取到一个*/
</code></pre></li>
</ul>
<p><img src="media/14816123522537/14816981982810.jpg" alt=""></p>
<h3 id="-">循环提取</h3>
<ul>
<li>循环提取:将所有符合要求的匹配内容提取出来</li>
<li><p>使用:</p>
<pre><code>  1.需要开启正则的全局模式
  var r = new RegExp(&#39;正则&#39;,&#39;g&#39;);
  var r = /正则/g;

  2.循环调用exec 直到返回null
</code></pre></li>
<li><p>案例:</p>
<pre><code>  eg: 从‘abc123ddds567sss789lkj’中提取数字

  var str = ‘abc123ddds567sss789lkj’;
  // 1.全局模式
  var regexp = /\d+/g;

  // 2.循环匹配
  var result;
  while(result = regexp.exec(str)){
      console.log(result);
  }

  /*每次匹配到的都是一个数组,数组中的第0项是匹配内容的对象*/
</code></pre></li>
</ul>
<p><img src="media/14816123522537/14816980680451.jpg" alt=""></p>
<h3 id="-">分组提取</h3>
<blockquote>
<p>将匹配到的结果进行解析,在正则中使用括号()进行分组,那么得到的结果将会是一个数组,数组的长度是正则中左括号出现的次数+1,第0项数据是整个正则的匹配结果,后续项分别是每一对括号匹配到的数据,其中从左向右出现的左括号分别被编号1,2,3...</p>
</blockquote>
<pre><code>// 提取出这个字符串中的邮箱 以及每一个邮箱的用户名和主机地址
var str = &#39;我有一个邮箱, 是 abc@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com&#39;
var r = /([a-zA-Z\d]+)@([a-zA-Z\d]+(\.[a-zA-Z\d]+)+)/g;
var res = r.exec( str );
console.log(res);

/*单个提取*/
</code></pre><p><img src="media/14816123522537/14817001680277.jpg" alt=""></p>
<pre><code>// 提取邮箱出这个字符串中的邮箱 以及每一个邮箱的用户名和主机地址
var str = &#39;我有一个邮箱, 是 abc@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com&#39;
var r = /([a-zA-Z\d]+)@([a-zA-Z\d]+(\.[a-zA-Z\d]+)+)/g;
var res;
while (res = r.exec(str)){
    console.log( &#39;邮箱是: &#39; + res[ 0 ] + 
                 &#39;, 用户名: &#39; + res[ 1 ] + 
                 &#39;, 主机名: &#39; + res[ 2 ] );
}

/*提取出这个字符串中所有的邮箱*/
</code></pre><p><img src="media/14816123522537/14817003938204.jpg" alt=""></p>
<h2 id="-">匹配但不捕获元字符</h2>
<blockquote>
<p>在组中添加<code>?:</code>后,依旧会去匹配这个组,但是不会出现在结果中</p>
</blockquote>
<pre><code>// 提取出这个字符串中的邮箱 以及每一个邮箱的用户名和主机地址
var str = &#39;我有一个邮箱, 是 abc@itcast.cn, 还有 abc@126.com, 和 1234567@qq.com&#39;
var r = /([a-zA-Z\d]+)@([a-zA-Z\d]+(\.[a-zA-Z\d]+)+)/g;
var res = r.exec( str );
console.log(res);
</code></pre><p><img src="media/14816123522537/14817008419111.jpg" alt=""></p>
<h2 id="-">反向引用</h2>
<blockquote>
<p>在正则表达式中使用组匹配到某一个数据,可以在该正则表达式中使用‘\数字’的方式引用该组,数字代表被引用组的编号</p>
</blockquote>
<pre><code>// 提取str中的html标签
var str = &#39;123&lt;div&gt;456&lt;/div&gt;78&lt;span&gt;9&lt;/span&gt;0&lt;i&gt;&lt;/i&gt;abc&#39;;
// \1表示引用前面的组(\w+)
var r = /&lt;(\w+)&gt;.*&lt;\/\1&gt;/g;
// 循环提取
var res;
while ( res = r.exec(str) ) {
    console.log( res[ 0 ] );
}
</code></pre><p><img src="media/14816123522537/14817016582362.jpg" alt=""></p>
<h2 id="-">贪婪模式</h2>
<pre><code>凡是在正则表达式中, 涉及到次数限定的, 一般默认都是尽可能的多匹配.

取消贪婪模式. 在次数限定符后面加上 ?

注意: 贪婪模式性能会略高于非贪婪模式, 所以开发的时候. 一般不考虑贪婪的问题
    只有代码匹配结果出现问题了, 一般一次多匹配了, 才会取消贪婪

- 多个贪婪在一起的时候的强度:第一个最强 后面强度一样

/(\d+)(\d+)(\d+)/.exec(&#39;1234567&#39;);

&#39;12345&#39;,&#39;6&#39;,&#39;7&#39;

- 取消贪婪模式

/(\d+?)(\d+)(\d+)/.exec(&#39;1234567&#39;);

&#39;1&#39;,&#39;23456&#39;,&#39;7&#39;
</code></pre>
          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>